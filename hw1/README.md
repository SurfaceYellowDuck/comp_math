Гипотеза:
В различных системах используются разные архитектуры доступа к памяти. В системах с процессором apple silicon m1
используется архитектура UMA(uniform memory access), NUMA(non uniform memory access) в свою очередь используется в Intel
Xeon и AMD Opteron. Первая предполагает общую шину данных для всех процессоров, поэтому каждое ядро имеет равноправный
доступ памяти. Вторая предполагает разделение памяти на несколько участков между ядрами(каждому ядру свой
участок памяти), что позволяет сократить время доступа к определенному, для ядра, участку памяти, но требует от
разработчика учитывать размер блока памяти для каждого ядра, размер строки кэша, и последовательность адрессов.

Для того, чтобы ускорить работу программы при использовании процессора с архитектурой NUMA
используются различные оптимизации. Применительно к задаче, можно подсчитать размеры блоков так, чтобы
минимизировать количество операций пересылки данных между ядрами. 

Например:, при размере строки кэша в 256 байт, 8-байтовых значениях данных и размере блока 64х64 объем пересылаемых данных составил:
    
    1) 64 * 3 * 8 / 256 = 6; 
    2) 64 / 3 = 22; 
    3)6 * 22 = 132 строки кэша, при размере блока 128х32 – всего 72 строки.

Задачи:

1)Первая задача состоит в том, чтобы проверить, ускорит ли данная оптимизация работу программы, если в системе используется
процессор с UMA архитектурой. 

2)Вторая задача залючается в том, чтобы взять различные функции, и посмотреть, как на них будет работать алгоритм.

Условия проведения эксперимента:

    ОС: macOS Sonoma 14.4
    Чип: Apple Silicon M1
    ОЗУ: 16 GB
    Размер кэш линии: 128 Байт
    Точность: 0.1
    Функция: 
![Image alt](https://github.com/SurfaceYellowDuck/comp_math/blob/main/hw1/u.png)

Предположение: оптимизация никак не должна уменьшить время работы программы.

Были проведены тестовые запуски программы со следующими параметрами:
https://docs.google.com/spreadsheets/d/1Kr6mBshpPjPIK5w6MVPC9n3UVmfN_N63pcOBlvkAG_U/edit?usp=sharing .
Также был воспроизведен эксперимент из книги, при размере матрицы 512(+2)x512(+2). Время работы программы при размере
блока
64x64 cоставило 0.411397 с. , а при размере блока 128x32 0.403926. Из таблицы и результатов воспроизведенного опыта из
книги видно, что кратность размера блока никак не влияет на ускорение работы программы, что совпадает с
предположением. Также была замечена закономерность: при увеличении размера блока без изменения размера
сетки происходит существенное ускорение программы. Это связано с тем, что сетка обрабатывается более оптимальным
образом, и отношение (количество блоков требующих обработки) /  (количество работающих потоков) стремится к единице при
обработки диагонали матрицы. Таким образом, при правильно подобранном размере блока скорость работы программы может
увеличиться в 1.5-1.6 раза. Но если блок будет слишком большим, то время работы программы может увеличиться. Это можно
заметить, если оставить размер матрицы из предыдущего эксперимента, и выбрать размер блока в 256x256. При таком размере
блока максимальное количество обрабатываемых элементов на диагонали уменьшается, и по этой причине некоторые потоки простаивают без
работы. Время обработки сетки при таком размере блока составило 0.61915 с., что подтверждает данное утверждениие.

Результаты эксперимента:

- При увеличении размера блока ускорение работы алгоритма до 1.5-1.6 раза.
- Кратность размера блока не влияет на скорость работы программы, эта оптимизация применима только к процессорам с NUMA
  архитектурой.
- Стоит быть внимательными при увеличении размеров блока. Если размер блока относительно размера сетки будет слишком
  большим (получится так, что на диагонали матрицы будет меньше блоков, чем имеющихся потоков), то программа будет
  выполняться последовательно, или почти последовательно.

Вторая часть эксперимента:

  Было проведено наблюдение по тому, как изменяется время работы программы, и количество необходимых итераций для достижения
необходимой точности, если добавить коэффицент k перед функцией u. 

Условия выглядит следующим образом:

    k = 20
    Начальное приближение: диапазоны случайных чисел [-100; 100], [-1000;1000]
    Функция:
![Image alt](https://github.com/SurfaceYellowDuck/comp_math/blob/main/hw1/u.png)

Ход эксперимента:
  Было проведено по 10 запусков программы, результаты представлены в файлах res 1, 
res2, res 3. Они показывают, что если значения начальнго приближение - это рандомные числа из диапозона от -100 до 100, то 
в среднем время работы будет почти всегда одинаковым, без выбросов т.к. значения из этого диапозона ближе к возможным значениям приближаемой 
функции. Если же брать диапозон от -1000 до 1000, то количество выбросов по времени растет(но только с увеличением времени) т.к. вероятность 
сразу не попасть в число, близкое к значению функции сильно растет.

Вычисления, подтверждающие выводы относительно выбора диапозонов случайных значений от -1000 до 1000 и -100; 100:

       13.5285549 - среднее
       1.301664823 - стандартное отклонение
       0.754551 - абсолютная погрешность при коэф-те доверия 90%
       13 +- 0.754551 - доверительный интервал.

      12.8538317 - среднее
      0.04435124427 - стандартное отклонение
      0.025710 - погрешность
      12.8538317 +- 0.025710 - доверительный интервал

В ходе второй части эксперимента таже было замечено, что при увеличении коэффицента k перед перед функцией u при 
постоянном диапозоне случайных чисел начального приближения, количество итераций, необходимых для приближения растет 
линейно, т.к. при увеличении значения функции необходимо сделать больше операций для приближения значений внутри сетки.
