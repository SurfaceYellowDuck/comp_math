Гипотеза:
В различных системах используются разные архитектуры доступа к памяти. В системах с процессором apple silicon m1
используется архитектура UMA(uniform memory access), NUMA(non uniform memory access) в свою очередь используется в Intel
Xeon и AMD Opteron. Первая предполагает общую шину данных для всех процессоров, поэтому каждое ядро имеет равноправный
доступ памяти. Вторая предполагает разделение памяти на несколько участков между ядрами(каждому ядру свой
участок памяти), что позволяет сократить время доступа к определенному, для ядра, участку памяти, но требует от
разработчика учитывать размер блока памяти для каждого ядра, размер строки кэша, и последовательность адрессов.

Для того, чтобы ускорить работу программы при использовании процессора с архитектурой NUMA
используются различные оптимизации. Применительно к задаче, можно подсчитать размеры блоков так, чтобы
минимизировать количество операций пересылки данных между ядрами. Например:, при размере строки кэша в 256 байт,
8-байтовых значениях данных и
размере блока 64х64 объем пересылаемых данных 132(64 * 3 * 8 / 256 = 6; 64 / 3 = 22; 6 * 22 = 132) строки кэша, при
размере блока. 128х32 – всего 72 строки.

Задача состоит в том, чтобы проверить, ускорит ли данная оптимизация работу программы, если в системе используется
процессор с UMA архитектурой.

Условия проведения эксперимента:
ОС: macOS Sonoma 14.4
Чип: Apple Silicon M1
ОЗУ: 16 GB
Размер кэш линии: 128 Байт

Предположение: оптимизация никак не должна уменьшить время работы программы.

Были проведены тестовые запуски программы со следующими параметрами:
https://docs.google.com/spreadsheets/d/1Kr6mBshpPjPIK5w6MVPC9n3UVmfN_N63pcOBlvkAG_U/edit?usp=sharing .
Также был воспроизведен эксперимент из книги, при размере матрицы 512(+2)x512(+2). Время работы программы при размере
блока
64x64 cоставило 0.411397 с. , а при размере блока 128x32 0.403926. Из таблицы и результатов воспроизведенного опыта из
книги видно, что четность размера блока никак не влияет на ускорение работы программы, что совпадает с
предположением. Зато была замечена закономерность: при увеличении размера блока без изменения размера
сетки происходит существенное ускорение программы. Это связано с тем, что сетка обрабатывается более оптимальным
образом, и отношение (количество блоков требующих обработки) /  (количество работающих потоков) стремится к единице при
обработки диагонали матрицы. Таким образом, при правильно подобранном размере блока скорость работы программы может
увеличиться в 1.5-1.6 раза. Но если блок будет слишком большим, то время работы программы может увеличиться. Это можно
заметить, если оставить размер матрицы из предыдущего эксперимента, и выбрать размер блока в 256x256. При таком размере
блока максимальное количество обрабатываемых элементов на диагонали уменьшается, и по этой причине некоторые потоки простаивают без
работы. Время обработки сетки при таком размере блока составило 0.61915, что подтверждает данное утверждениие.

Таким образом, результаты эксперимента выглядят следующим образом :

- При увеличении размера блока ускорение работы алгоритма до 1.5-1.6 раза.
- Четность размера блока не влияет на скорость работы программы, эта оптимизация применима только к процессорам с NUMA
  архитектурой.
- Стоит быть внимательными при увеличении размеров блока. Если размер блока относительно размера сетки будет слишком
  большим (получится так, что на диагонали матрицы будет меньше блоков, чем имеющихся потоков), то программа будет
  выполняться последовательно, или почти последовательно.
